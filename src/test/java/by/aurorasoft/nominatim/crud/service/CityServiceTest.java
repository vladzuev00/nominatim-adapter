package by.aurorasoft.nominatim.crud.service;

import by.aurorasoft.nominatim.base.AbstractJunitSpringBootTest;
import by.aurorasoft.nominatim.crud.model.dto.City;
import org.junit.Test;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.Polygon;
import org.locationtech.jts.geom.prep.PreparedGeometry;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;
import java.util.Map;

import static by.aurorasoft.nominatim.testutil.GeometryUtil.createLineByText;
import static by.aurorasoft.nominatim.testutil.GeometryUtil.createPolygonByText;
import static by.aurorasoft.nominatim.testutil.IdUtil.mapToSortedIds;
import static java.util.stream.Collectors.toMap;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public final class CityServiceTest extends AbstractJunitSpringBootTest {

    @Autowired
    private CityService service;

    @Autowired
    private GeometryFactory geometryFactory;

    @Test
    @Sql(statements = "DELETE FROM city WHERE id NOT IN (24, 27, 63)")
    public void allCitiesShouldBeFound() {
        final Page<City> actual = service.findAll(PageRequest.of(0, 3));
        final List<Long> actualIds = mapToSortedIds(actual);
        final List<Long> expectedIds = List.of(24L, 27L, 63L);
        assertEquals(expectedIds, actualIds);
    }

    @Test
    @Sql(statements = "DELETE FROM city")
    public void allCitiesShouldNotBeFound() {
        final Page<City> actual = service.findAll(PageRequest.of(0, 3));
        assertTrue(actual.isEmpty());
    }

    @Test
    @Sql(statements = "DELETE FROM city WHERE id NOT IN (63, 58)")
    public void preparedGeometriesByPreparedBoundingBoxesShouldBeFound() {
        final Map<Geometry, Geometry> actual = findGeometriesByBoundingBoxes();
        final Map<Geometry, Geometry> expected = Map.of(
                createPolygon("POLYGON((26.5713051 51.3218903,26.5786303 51.3192656,26.5831032 51.3074501,26.601612 51.2990736,26.6273034 51.2947553,26.6366959 51.3036507,26.6459503 51.3315349,26.637939 51.3463765,26.6047889 51.3591434,26.5759207 51.355952,26.5713051 51.3218903))"),
                createPolygon("POLYGON((26.5713051 51.3218903,26.5786303 51.3192656,26.5831032 51.3074501,26.601612 51.2990736,26.6273034 51.2947553,26.6366959 51.3036507,26.6459503 51.3315349,26.637939 51.3463765,26.6047889 51.3591434,26.5759207 51.355952,26.5713051 51.3218903))"),
                createPolygon("POLYGON((26.1181731 53.5669171,26.1220879 53.5627187,26.1237694 53.5617895,26.1287667 53.5588824,26.1305154 53.5584735,26.1395147 53.556369,26.1534094 53.5505,26.1626521 53.5546695,26.1555441 53.5579651,26.1575208 53.5650461,26.1570622 53.567929,26.1569957 53.5684761,26.1600534 53.5728229,26.1527336 53.5759405,26.1480035 53.5781995,26.1423211 53.5797467,26.137291 53.5819,26.1336929 53.5823034,26.129894 53.5816433,26.1235157 53.5776559,26.1222441 53.5696428,26.1193288 53.5684393,26.1193089 53.5682134,26.1181731 53.5669171))"),
                createPolygon("POLYGON((26.1181731 53.5669171,26.1220879 53.5627187,26.1237694 53.5617895,26.1287667 53.5588824,26.1305154 53.5584735,26.1395147 53.556369,26.1534094 53.5505,26.1626521 53.5546695,26.1555441 53.5579651,26.1575208 53.5650461,26.1570622 53.567929,26.1569957 53.5684761,26.1600534 53.5728229,26.1527336 53.5759405,26.1480035 53.5781995,26.1423211 53.5797467,26.137291 53.5819,26.1336929 53.5823034,26.129894 53.5816433,26.1235157 53.5776559,26.1222441 53.5696428,26.1193288 53.5684393,26.1193089 53.5682134,26.1181731 53.5669171))")
        );
        assertEquals(expected, actual);
    }

    @Test
    @Sql(statements = "DELETE FROM city")
    public void preparedGeometriesByPreparedBoundingBoxesShouldNotBeFound() {
        final Map<PreparedGeometry, PreparedGeometry> actual = service.findPreparedGeometriesByPreparedBoundingBoxes();
        assertTrue(actual.isEmpty());
    }

    @Test
    public void intersectedPreparedGeometriesShouldBeFound() {
        final LineString givenLine = createLine("LINESTRING (24.356189727783203 52.20729446411133, 24.357080459594727 52.207244873046875, 24.35715675354004 52.206912994384766, 24.357515335083008 52.19639205932617, 24.367416381835938 52.18671798706055, 24.369365692138672 52.185455322265625, 24.369239807128906 52.18511199951172, 24.369524002075195 52.18476104736328, 24.37179183959961 52.18284225463867, 24.344202041625977 52.178504943847656, 24.341712951660156 52.17830276489258, 24.336538314819336 52.178810119628906, 24.334169387817383 52.179500579833984, 24.32586669921875 52.1827278137207, 24.32234764099121 52.18429946899414, 24.300270080566406 52.196861267089844, 24.297218322753906 52.1981086730957, 24.293201446533203 52.19924545288086, 24.28963279724121 52.19975280761719, 24.285850524902344 52.19984817504883, 24.281848907470703 52.19951248168945)");

        final List<Geometry> actualGeometries = findIntersectedGeometries(givenLine);
        final List<Geometry> expectedGeometries = List.of(
                createPolygon("POLYGON((24.30099 52.2035525,24.3012972 52.2030546,24.3019143 52.203158,24.3050722 52.1967738,24.3078228 52.1980163,24.3090412 52.1986989,24.3093724 52.1990781,24.3075155 52.1994396,24.3094089 52.2046335,24.3179665 52.2063157,24.3180462 52.2061493,24.3185556 52.1996258,24.3215862 52.1994688,24.3257641 52.1999598,24.3254314 52.2006774,24.3289684 52.2013798,24.3360179 52.2006169,24.3364369 52.1975954,24.333208 52.1976483,24.3329615 52.1969156,24.3293528 52.1962462,24.3287094 52.1949546,24.3301239 52.1944202,24.3295458 52.1921471,24.3295511 52.1920421,24.3299659 52.1919192,24.3293276 52.1904114,24.3293276 52.190227,24.3341072 52.1893901,24.3358943 52.1889555,24.3382207 52.1885093,24.3404177 52.1882293,24.3411488 52.1879104,24.3407153 52.1868318,24.3428985 52.1858392,24.3425111 52.1853253,24.345118 52.1846652,24.3462109 52.1840208,24.3473525 52.1836628,24.3510728 52.1823619,24.3519607 52.1837845,24.3532498 52.1834347,24.3543153 52.1817737,24.3613719 52.1824006,24.3648168 52.1842304,24.367968 52.184469,24.3755597 52.1849621,24.3769141 52.1908673,24.3752891 52.1935691,24.3819663 52.1961835,24.3877542 52.1984248,24.3935634 52.201969,24.4018618 52.2067702,24.4015503 52.210761,24.4014409 52.2144367,24.3992691 52.2159778,24.400502 52.221388,24.3990351 52.2219826,24.3986769 52.2229739,24.3985382 52.2234025,24.3942393 52.2231262,24.393381 52.2217723,24.3871231 52.2215427,24.3851952 52.2184754,24.383508 52.214202,24.3780824 52.2142028,24.3773784 52.2160499,24.3779779 52.2175641,24.3782696 52.2182531,24.3782842 52.2185658,24.3783623 52.2212635,24.37592 52.22179,24.3758986 52.2233477,24.3803677 52.2227949,24.3808112 52.2240813,24.3808857 52.2260338,24.38347 52.22814,24.3837481 52.2289379,24.3854935 52.2302199,24.3838554 52.2311226,24.3859285 52.2321893,24.3741645 52.2384773,24.3764303 52.2400176,24.3657992 52.2457831,24.3609592 52.2475063,24.3566085 52.2452996,24.3505139 52.2437003,24.3424002 52.2495345,24.3372877 52.2474465,24.3322158 52.2508635,24.3269089 52.2480108,24.3332583 52.2428361,24.3326626 52.2425465,24.3324671 52.2425026,24.3320957 52.2378204,24.3319348 52.2376693,24.3316773 52.2375773,24.3174186 52.2363881,24.3172041 52.2363684,24.3168822 52.2363618,24.3121079 52.236986,24.3116814 52.2364255,24.3100479 52.2342789,24.3118944 52.2325676,24.3129656 52.2317171,24.3163265 52.2286966,24.3175306 52.2276174,24.3173248 52.2270315,24.3172534 52.2267875,24.3172255 52.226692,24.3169928 52.2254632,24.3169757 52.2253825,24.3169471 52.2240831,24.316571 52.2235721,24.3164771 52.2231163,24.3166294 52.2228807,24.3165841 52.2218624,24.3148144 52.2205577,24.3149844 52.2201277,24.317005 52.2187991,24.3191971 52.2179896,24.3192262 52.2178941,24.3193698 52.2177598,24.319903 52.2172309,24.3203265 52.2168188,24.3198269 52.2162739,24.3201192 52.215739,24.3192333 52.2145387,24.3199958 52.2117656,24.3282186 52.2084797,24.30099 52.2035525))")
        );
        assertEquals(expectedGeometries, actualGeometries);
    }

    @Test
    @Sql(statements = "DELETE FROM city WHERE id = 31")
    public void intersectedPreparedGeometriesShouldNotBeFound() {
        final LineString givenLine = createLine("LINESTRING (24.356189727783204 52.20729446411133, 24.357080459594727 52.207244873046875, 24.35715675354004 52.206912994384766, 24.357515335083008 52.19639205932617, 24.367416381835938 52.18671798706055, 24.369365692138672 52.185455322265625, 24.369239807128906 52.18511199951172, 24.369524002075195 52.18476104736328, 24.37179183959961 52.18284225463867, 24.344202041625977 52.178504943847656, 24.341712951660156 52.17830276489258, 24.336538314819336 52.178810119628906, 24.334169387817383 52.179500579833984, 24.32586669921875 52.1827278137207, 24.32234764099121 52.18429946899414, 24.300270080566406 52.196861267089844, 24.297218322753906 52.1981086730957, 24.293201446533203 52.19924545288086, 24.28963279724121 52.19975280761719, 24.285850524902344 52.19984817504883, 24.281848907470703 52.19951248168945)");

        final List<PreparedGeometry> actual = service.findIntersectedPreparedGeometries(givenLine);
        assertTrue(actual.isEmpty());
    }

    private Map<Geometry, Geometry> findGeometriesByBoundingBoxes() {
        return unwrapGeometries(service.findPreparedGeometriesByPreparedBoundingBoxes());
    }

    private static Map<Geometry, Geometry> unwrapGeometries(final Map<PreparedGeometry, PreparedGeometry> source) {
        return source.entrySet()
                .stream()
                .collect(toMap(entry -> entry.getKey().getGeometry(), entry -> entry.getValue().getGeometry()));
    }

    private Polygon createPolygon(final String text) {
        return createPolygonByText(text, geometryFactory);
    }

    private LineString createLine(final String text) {
        return createLineByText(text, geometryFactory);
    }

    private List<Geometry> findIntersectedGeometries(final LineString line) {
        return mapToGeometries(service.findIntersectedPreparedGeometries(line));
    }

    private static List<Geometry> mapToGeometries(final List<PreparedGeometry> preparedGeometries) {
        return preparedGeometries.stream()
                .map(PreparedGeometry::getGeometry)
                .toList();
    }
}
